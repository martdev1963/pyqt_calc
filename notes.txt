Simple Calculator App in PyQt

Here's a complete implementation of a simple calculator using PyQt5:

Martin@DESKTOP-HTLQ9GM /cygdrive/c/Users/Martin/Documents/Coding/pyqt_calc
$ pip install PyQt5
Requirement already satisfied: PyQt5 in c:\python312\lib\site-packages (5.15.11)
Requirement already satisfied: PyQt5-sip<13,>=12.15 in c:\python312\lib\site-packages (from PyQt5) (12.17.0)
Requirement already satisfied: PyQt5-Qt5<5.16.0,>=5.15.2 in c:\python312\lib\site-packages (from PyQt5) (5.15.2)

You can easily customize this calculator:
    Change the colors by modifying the stylesheet

    Add more operations (like square root or percentage)

    Add keyboard support

    Make the display show the full calculation history

Detailed Line-by-Line Explanation of the PyQt5 Calculator App

This explanation breaks down every part of the code to help you understand how the calculator works.

1. Importing Required Modules

import sys
from PyQt5.QtWidgets import QApplication, QMainWindow, QVBoxLayout, QLineEdit, QPushButton, QWidget, QGridLayout
from PyQt5.QtCore import Qt

    sys: Used to handle system-level operations (like exiting the app).

    PyQt5.QtWidgets: Contains UI components:

        QApplication: Manages the application's control flow.

        QMainWindow: Provides a main application window.

        QVBoxLayout & QGridLayout: For arranging widgets vertically or in a grid.

        QLineEdit: A text input field (used for the calculator display).

        QPushButton: Clickable buttons (numbers and operations).

        QWidget: Base class for all UI objects.

    PyQt5.QtCore.Qt: Provides enums like alignment flags (Qt.AlignRight).


2. Creating the CalculatorApp Class (Main Window)

class CalculatorApp(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Simple Calculator")
        self.setFixedSize(300, 400)


     Inherits from QMainWindow (a standard top-level window).

    super().__init__(): Calls the parent class constructor.

    setWindowTitle(): Sets the window title.

    setFixedSize(): Makes the window non-resizable (300Ã—400 pixels).


3. Setting Up the Central Widget & Layout

        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)
        
        self.layout = QVBoxLayout()
        self.central_widget.setLayout(self.layout)


    central_widget: The main container inside QMainWindow.

    setCentralWidget(): Assigns central_widget as the main area.

    QVBoxLayout(): A vertical box layout for stacking widgets.

    setLayout(): Applies the layout to central_widget.


4. Creating the Display (QLineEdit)

    def create_display(self):
        self.display = QLineEdit()
        self.display.setAlignment(Qt.AlignRight)
        self.display.setReadOnly(True)
        self.display.setStyleSheet("font-size: 24px; padding: 10px;")
        self.display.setMaxLength(15)
        self.layout.addWidget(self.display)

    QLineEdit(): A text box for displaying numbers.

    setAlignment(Qt.AlignRight): Right-aligns text.

    setReadOnly(True): Prevents manual typing.

    setStyleSheet(): Customizes font size and padding.

    setMaxLength(15): Limits input length to prevent overflow.

    addWidget(): Adds the display to the layout.


5. Creating the Buttons (QPushButton)

    def create_buttons(self):
        buttons_layout = QGridLayout()
        
        buttons = [
            '7', '8', '9', '/',
            '4', '5', '6', '*',
            '1', '2', '3', '-',
            '0', 'C', '=', '+'
        ]


    QGridLayout(): Arranges buttons in a grid (4 rows Ã— 4 columns).

    buttons: A list of button labels (numbers, operators, clear, equals).


Looping Through Buttons & Adding Them to the Grid

        for i, text in enumerate(buttons):
            button = QPushButton(text)
            button.setStyleSheet("font-size: 18px; padding: 10px;")
            button.clicked.connect(self.on_button_click)
            
            row = i // 4
            col = i % 4
            buttons_layout.addWidget(button, row, col)


    QPushButton(text): Creates a button with the given label.

    setStyleSheet(): Styles the button (font size, padding).

    clicked.connect(self.on_button_click): Connects the button click to a function.

    row = i // 4 and col = i % 4: Calculates grid position.

    addWidget(button, row, col): Places the button in the grid.


Special Cases: '=' and '0' Buttons

            if text == '=':
                buttons_layout.addWidget(button, row, col, 2, 1)  # Span 2 rows
            if text == '0':
                buttons_layout.addWidget(button, row, col, 1, 2)  # Span 2 columns
                i += 1  # Skip next column (since '0' takes 2 columns)


    = button spans 2 rows (rowspan=2).

    0 button spans 2 columns (colspan=2).

    i += 1: Skips the next column to avoid overlap.


6. Handling Button Clicks (on_button_click)

    def on_button_click(self):
        sender = self.sender()
        text = sender.text()

    sender(): Gets which button was clicked.

    text(): Retrieves the button's label (e.g., "7", "+").



Digit Buttons (0-9)

        if text.isdigit():
            self.current_input += text
            self.display.setText(self.current_input)


    If the button is a digit (isdigit()), append it to current_input.

    Update the display.


  Clear Button (C)

        elif text == 'C':
            self.current_input = ""
            self.previous_input = ""
            self.operation = None
            self.display.clear()

    Resets all calculator state variables.

    Clears the display.


Operator Buttons (+, -, *, /)

        elif text in '+-*/':
            if self.current_input:
                self.previous_input = self.current_input
                self.current_input = ""
                self.operation = text


    Stores the first number (current_input) in previous_input.

    Clears current_input for the next number.

    Saves the operator (+, -, etc.) in self.operation.


   Equals Button (=)

            elif text == '=':
            if self.previous_input and self.current_input and self.operation:
                try:
                    result = self.calculate(
                        float(self.previous_input),
                        float(self.current_input),
                        self.operation
                    )
                    self.display.setText(str(result))
                    self.current_input = str(result)
                    self.previous_input = ""
                    self.operation = None
                except ZeroDivisionError:
                    self.display.setText("Error")
                    self.current_input = ""
                    self.previous_input = ""
                    self.operation = None


    Checks if thereâ€™s a valid operation (previous_input, current_input, operation).

    Calls self.calculate() to compute the result.

    Displays the result (or "Error" if dividing by zero).

    Resets state if an error occurs.


7. Calculation Logic (calculate Method)

    def calculate(self, num1, num2, operation):
        if operation == '+':
            return num1 + num2
        elif operation == '-':
            return num1 - num2
        elif operation == '*':
            return num1 * num2
        elif operation == '/':
            return num1 / num2

    Takes two numbers (num1, num2) and an operator (operation).

    Returns the result of the arithmetic operation.

8. Running the Application

if __name__ == "__main__":
    app = QApplication(sys.argv)
    calculator = CalculatorApp()
    calculator.show()
    sys.exit(app.exec_())


    QApplication(sys.argv): Initializes the PyQt5 application.

    CalculatorApp(): Creates the calculator window.

    calculator.show(): Displays the window.

    app.exec_(): Starts the event loop.

    sys.exit(): Ensures a clean exit when the app closes.


Summary of Key Concepts

    PyQt5 Widgets: QMainWindow, QLineEdit, QPushButton, QVBoxLayout, QGridLayout.

    Event Handling: button.clicked.connect() triggers actions.

    State Management: current_input, previous_input, operation track calculations.

    Error Handling: Catches division by zero.

    Styling: setStyleSheet() for custom appearance.

This calculator can be extended with features like memory functions, keyboard input, 
or scientific operations. Let me know if you'd like to enhance it! ðŸš€






